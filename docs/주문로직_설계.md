# 주문 로직 설계 및 구현

## 개요
E-commerce 시스템의 핵심인 주문 처리 로직을 **Facade 패턴**을 활용하여 설계했습니다. 복잡한 주문 프로세스를 단일 트랜잭션으로 처리하면서도 각 도메인의 책임을 명확히 분리한 구조로 구현했습니다.

## 주문 프로세스 플로우

### 전체 주문 처리 단계
```
1. 장바구니 조회 (캐시 미사용)
2. 상품 검증 (존재 여부, 재고 확인)
3. 주문 생성 (PENDING 상태)
4. 결제 처리
5. 재고 차감
6. 장바구니 비우기
7. 주문 완료 (COMPLETE 상태)
```

## 아키텍쳐 설계

### Facade 패턴 적용
```java
@Component
@RequiredArgsConstructor
public class OrderFacade {
    private final CartService cartService;
    private final OrderService orderService;
    private final PaymentService paymentService;
    private final ProductService productService;
    
    @Transactional
    public OrderResult order(OrderCriteria criteria) {
        // 복잡한 주문 프로세스 오케스트레이션
    }
}
```

**Facade 패턴 선택 이유:**
1. **복잡성 은닉**: 여러 서비스간 복잡한 상호작용을 단일 인터페이스로 제공
2. **트랜잭션 경계**: 전체 주문 프로세스를 하나의 트랜잭션으로 관리
3. **느슨한 결합**: Controller와 여러 Service 간의 직접적인 의존성 제거
4. **재사용성**: 주문 로직을 다른 컨텍스트에서도 재사용 가능

## 상세 구현 분석

### 1단계: 장바구니 조회
```java
// 카트조회 (캐시 미사용)
List<CartWithProductInfo> carts = cartService.findCartsWithoutCache(criteria.getUserId());
List<Long> productIds = carts.stream()
    .map(CartWithProductInfo::getProductId)
    .toList();
List<Long> cartIds = carts.stream()
    .map(CartWithProductInfo::getCartId)
    .toList();
```

**설계 포인트:**
- **캐시 미사용**: `findCartsWithoutCache()` 사용으로 최신 데이터 보장
- **데이터 추출**: 후속 단계에서 필요한 productIds, cartIds 미리 추출
- **불변 리스트**: `toList()` 사용으로 데이터 안정성 확보

### 2단계: 상품 검증
```java
// 상품검증
ValidateProductCommand validateProductCommand = new ValidateProductCommand(productIds);
productService.validateProduct(validateProductCommand);
```

**검증 내용:**
- 상품 존재 여부 확인
- 재고 수량 충분 여부 확인
- 판매 가능 상태 확인

### 3단계: 주문 생성 (PENDING)
```java
// 주문생성 PENDING
List<OrderProduct> products = carts.stream().map(OrderProduct::from).toList();
CreateOrderCommand createOrderCommand = new CreateOrderCommand(criteria.getUserId(), products);
OrderInfo orderInfo = orderService.createOrder(createOrderCommand);
```

**주문 생성 로직:**
- **OrderProduct 변환**: 장바구니 데이터를 주문 상품으로 변환
- **PENDING 상태**: 초기 주문 상태를 PENDING으로 설정
- **주문번호 생성**: 타임스탬프 + 랜덤값으로 고유한 주문번호 생성

#### 주문번호 생성 전략
```java
private static String generateOrderNo() {
    String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMddHHmmssSSS"));
    int randomValue = ThreadLocalRandom.current().nextInt(9999);
    return timestamp + String.format("%04d", randomValue);
}
```

**주문번호 특징:**
- **형태**: `yyyyMMddHHmmssSSS` + `4자리 랜덤값`
- **예시**: `2024123115301245679876`
- **장점**: 시간순 정렬 가능, 고유성 보장

### 4단계: 결제 처리
```java
// 결제생성
PayCommand payCommand = new PayCommand(criteria.getUserId(), orderInfo.getOrderId(), orderInfo.getTotalPrice());
PaymentInfo paymentInfo = paymentService.pay(payCommand);
```

**결제 처리 특징:**
- **외부 결제 시스템 연동**: PaymentClient 인터페이스를 통한 추상화
- **Mock 결제**: 개발 단계에서 MockPaymentClient 사용
- **결제 정보 저장**: 결제 결과를 Payment 엔티티로 저장

### 5단계: 재고 차감
```java
// 재고차감
DecreaseStockCommand decreaseStockCommand = new DecreaseStockCommand(products);
productService.decreaseStock(decreaseStockCommand);
```

**재고 처리 전략:**
- **원자적 연산**: 모든 상품의 재고를 한 번에 처리
- **실패 시 롤백**: 일부 상품이라도 재고 부족 시 전체 트랜잭션 롤백
- **동시성 제어**: Pessimistic Lock으로 동시 주문 시 재고 정합성 보장

### 6단계: 장바구니 비우기
```java
// 카트 clear
cartService.clearCart(new ClearCartCommand(criteria.getUserId(), cartIds));
```

**장바구니 정리:**
- **배치 삭제**: 여러 장바구니 항목을 한 번에 삭제
- **캐시 무효화**: @CacheEvict로 해당 사용자의 장바구니 캐시 삭제
- **데이터 정합성**: 주문 완료 후 장바구니와 실제 재고 상태 일치

### 7단계: 주문 완료
```java
// 주문완료 PAID
CompleteOrderCommand completeOrderCommand = new CompleteOrderCommand(orderInfo.getOrderId());
orderInfo = orderService.completeOrder(completeOrderCommand);

return OrderResult.from(orderInfo, paymentInfo);
```

**주문 완료 처리:**
- **상태 변경**: PENDING → COMPLETE
- **완료 시간 기록**: `paidAt` 필드에 현재 시간 저장
- **결과 반환**: 주문 정보와 결제 정보를 조합한 OrderResult 반환

## 도메인 모델 설계

### Order 엔티티 핵심 구조
- **userId**: 주문자 식별
- **orderNo**: 고유 주문번호 (타임스탬프 + 랜덤)
- **totalPrice**: 주문 총액
- **status**: 주문 상태 (PENDING, COMPLETE, CANCELLED)
- **paidAt**: 결제 완료 시간
- **orderLines**: 주문 상품 목록 (1:N 관계)

**핵심 비즈니스 메서드:**
- `calculateTotalPrice()`: 주문 라인 합계로 총액 자동 계산
- `complete()`: 주문 완료 처리 및 상태 검증
- `addOrderLine()`: 주문 라인 추가 및 연관관계 설정

### OrderLine 엔티티 설계
- **productId**: 상품 식별 (Product와 느슨한 결합)
- **quantity**: 주문 수량
- **price**: 주문 시점 가격 (스냅샷)
- **totalPrice**: 라인별 총액 (quantity × price)

**설계 포인트:**
- **가격 스냅샷**: 주문 후 상품 가격 변동에 영향받지 않음
- **느슨한 결합**: productId로 참조하여 Product 엔티티와 독립성 유지

## 트랜잭션 관리

### 단일 트랜잭션 처리
```java
@Transactional
public OrderResult order(OrderCriteria criteria) {
    // 7단계 주문 프로세스 모두 하나의 트랜잭션
}
```

**ACID 속성 보장:**
- **원자성**: 7단계 모두 성공하거나 모두 실패
- **일관성**: 재고, 주문, 결제, 장바구니 상태 간 일관성 유지
- **격리성**: 동시 주문 처리 시 데이터 간섭 방지
- **지속성**: 주문 완료 후 데이터 영구 저장

### 실패 시나리오 처리
1. **상품 검증 실패**: 존재하지 않는 상품 → BusinessException
2. **재고 부족**: 재고 수량 부족 → 전체 롤백
3. **결제 실패**: 외부 결제 시스템 오류 → 전체 롤백
4. **시스템 오류**: 데이터베이스 오류 → 전체 롤백

## 확장성 고려사항

### 1. 결제 시스템 확장
- **PaymentClient 인터페이스**: 다양한 결제 수단 추가 가능
- **전략 패턴**: 결제 방식별 구현체 교체 가능

### 2. 주문 상태 확장
- **OrderStatus enum**: 필요에 따라 상태 추가 가능
- **상태 전이**: Order 엔티티에서 비즈니스 규칙 관리

### 3. 이벤트 처리
- **주문 완료 이벤트**: 향후 알림, 재고 관리 등 확장 가능
- **비동기 처리**: 무거운 작업의 비동기 처리 가능

## 결론

주문 로직은 E-commerce 시스템의 가장 복잡하고 중요한 부분입니다. 본 설계에서는 다음과 같은 핵심 원칙을 적용했습니다:

1. **Facade 패턴**: 복잡한 프로세스를 단순한 인터페이스로 제공
2. **단일 트랜잭션**: 데이터 일관성과 원자성 보장
3. **도메인 중심 설계**: 비즈니스 로직을 도메인 엔티티에 캡슐화
4**확장 가능한 구조**: 향후 요구사항 변화에 대응 가능한 유연성

이러한 설계를 통해 안정적이고 확장 가능한 주문 처리 시스템을 구축할 수 있었습니다.
