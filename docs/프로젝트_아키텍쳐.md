# 프로젝트 아키텍쳐 설계

## 개요
본 프로젝트는 **5-Layer 아키텍쳐**를 기반으로 설계된 Spring Boot 기반의 E-commerce 백엔드 시스템입니다. 전통적인 레이어드 아키텍쳐에 **클린 아키텍쳐**의 의존성 역전 원칙을 적용하여 모든 레이어가 도메인을 중심으로 설계되도록 하였습니다.

## 아키텍쳐 레이어 구조

### 1. Interfaces Layer (인터페이스 계층)
```
└── interfaces/
    ├── product/
    │   ├── ProductController.java
    │   └── request/ProductSearchRequest.java
    ├── cart/
    │   ├── CartController.java
    │   └── request/*.java
    └── order/
        ├── OrderController.java
        └── CreateOrderRequest.java
```

**역할**: 외부와의 접점을 담당하는 계층
- REST API 엔드포인트 제공
- HTTP 요청/응답 처리
- 요청 데이터 검증 및 변환
- 표준화된 `ApiResponse` 래핑

### 2. Facade Layer (퍼사드 계층)
```
└── facade/
    └── order/
        ├── OrderFacade.java
        ├── OrderCriteria.java
        └── OrderResult.java
```

**역할**: 복잡한 비즈니스 플로우 오케스트레이션
- 여러 Service 간의 복잡한 상호작용 조율
- 트랜잭션 경계 관리 (`@Transactional`)
- 비즈니스 워크플로우 구현 (주문 → 결제 → 재고차감 → 주문완료)

### 3. Service Layer (서비스 계층)
```
└── service/
    ├── product/
    │   ├── ProductService.java
    │   ├── command/*.java
    │   └── info/*.java
    ├── cart/
    │   ├── CartService.java
    │   ├── command/*.java
    │   └── info/*.java
    ├── order/
    │   ├── OrderService.java
    │   ├── command/*.java
    │   └── info/*.java
    └── payment/
        ├── PaymentService.java
        ├── command/*.java
        └── info/*.java
```

**역할**: 애플리케이션 비즈니스 로직 구현
- **Command-Query 패턴** 적용
- 도메인 서비스 호출 및 조율
- 데이터 변환 (Domain ↔ DTO)
- Redis 캐싱 처리 (`@Cacheable`, `@CacheEvict`)

### 4. Domain Layer (도메인 계층)
```
└── domain/
    ├── product/
    │   ├── Product.java
    │   ├── ProductRepository.java
    │   └── ProductCategory.java
    ├── cart/
    │   ├── Cart.java
    │   ├── CartRepository.java
    │   └── dto/CartWithProductDto.java
    ├── order/
    │   ├── Order.java
    │   ├── OrderLine.java
    │   ├── OrderRepository.java
    │   └── OrderStatus.java
    └── payment/
        ├── Payment.java
        ├── PaymentRepository.java
        └── client/PaymentClient.java
```

**역할**: 핵심 비즈니스 도메인 모델링
- **도메인 엔티티**: 비즈니스 규칙과 제약조건 구현
- **도메인 서비스**: 복잡한 비즈니스 로직 캡슐화
- **리포지토리 인터페이스**: 데이터 접근 추상화
- **Value Object**: 도메인 개념 표현 (ProductCategory, OrderStatus)

### 5. Infrastructure Layer (인프라 계층)
```
└── infra/
    ├── product/
    │   ├── ProductJpaRepository.java
    │   ├── ProductJpaRepositoryCustom.java
    │   ├── ProductJpaRepositoryImpl.java
    │   └── ProductRepositoryImpl.java
    ├── cart/
    │   ├── CartJpaRepository.java
    │   ├── CartJpaRepositoryCustom.java
    │   ├── CartJpaRepositoryImpl.java
    │   └── CartRepositoryImpl.java
    └── payment/
        └── client/MockPaymentClient.java
```

**역할**: 외부 시스템과의 통합 구현
- JPA 리포지토리 구현체
- QueryDSL 동적 쿼리 구현
- 외부 API 클라이언트 구현
- 데이터베이스 접근 세부사항 처리

## Domain Layer에 인터페이스가 있는 이유

### 1. DIP 준수
```java
// Domain Layer에 정의된 인터페이스
public interface ProductRepository {
    Page<Product> searchProducts(ProductSearchCondition condition);
    List<Product> findAllByIds(List<Long> ids);
}

// Infrastructure Layer에서 구현
@Repository
public class ProductRepositoryImpl implements ProductRepository {
    // 실제 구현
}
```

**이유**: 고수준 모듈(Domain)이 저수준 모듈(Infrastructure)에 의존하지 않도록 설계

### 2. 레이어드 아키텍쳐에서 의존성 역전
- 전통적인 레이어드 아키텍쳐: Interfaces → Service → Domain → Infrastructure 순서로 의존
- 클린 아키텍쳐 적용: **모든 레이어가 Domain을 바라보도록** 의존성 역전
- Domain Layer의 인터페이스를 통해 Infrastructure의 구체적인 구현체와 분리

### 3. 비즈니스 로직의 순수성 보장
```java
@Service
public class ProductService {
    private final ProductRepository productRepository; // 인터페이스에 의존
    
    public void validateProduct(ValidateProductCommand command) {
        // 비즈니스 로직에만 집중
        List<Product> products = productRepository.findAllByIds(command.getProductIds());
        // ...
    }
}
```

## 아키텍쳐 특징과 장점

### 1. 관심사의 분리
- 각 레이어는 명확하게 정의된 단일 책임을 가짐
- 변경의 영향도를 최소화하여 유지보수성 향상

### 2. 의존성 역전
- 상위 레이어가 하위 레이어의 추상화에 의존
- 구체적인 구현체 변경 시에도 비즈니스 로직 영향 없음

### 3. 테스트 용이성
- 각 레이어별 독립적인 단위 테스트 가능
- Mock 객체를 통한 격리된 테스트 환경 구성

### 4. 확장성
- 새로운 기능 추가 시 기존 구조를 해치지 않음
- 인터페이스 기반 설계로 다양한 구현체 교체 가능

### 5. 도메인 중심 설계
- 비즈니스 도메인이 아키텍쳐의 중심
- 기술적 세부사항으로부터 도메인 로직 보호
